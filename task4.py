# 4. * (вместо 3) Решить задачу 3 для ситуации, когда объём данных в файлах превышает объём ОЗУ (разумеется,
# не нужно реально создавать такие большие файлы, это просто задел на будущее проекта). Также реализовать парсинг
# данных из файлов - получить отдельно фамилию, имя и отчество для пользователей и название каждого хобби:
# преобразовать в какой-нибудь контейнерный тип (список, кортеж, множество, словарь). Обосновать выбор типа.
# Подумать, какие могут возникнуть проблемы при парсинге. В словаре должны храниться данные, полученные в результате
# парсинга.

import json

names = []
with open('users.csv', 'r', encoding='utf8') as f:
    for line in f:
        names.append(line.replace(',', ' ').strip())

hobbies = []
with open('hobby.csv', 'r', encoding='utf8') as f:
    for line in f:
        hobbies.append(line.strip())

names_hobbies_dict = {}

for i in range(0, len(names)):
    if len(names) < len(hobbies):
        exit(1)
    elif i < len(hobbies):
        names_hobbies_dict[names[i]] = (names[i].split(), hobbies[i].split(','))
    else:
        names_hobbies_dict[tuple(names[i].split())] = None

print(names_hobbies_dict)

with open('names_and_hobbies.json', 'w', encoding='utf8') as f:
    json.dump(names_hobbies_dict, f)

# Ругается на то, что ключ должен быть строкой, интом, флоатом, булом, нон, но у меня итак ключ строка - не понимаю почему

# Выбор среди типов пал на словари и кортежи. Кортежи были выбраны в целях экономии памяти, а также в данной задаче
# имена и интересы мы берём из файлов => нет необходимости вмешиваться в данные, а только к ним обращаться,
# используя кортежи это сделать просто. Словари были выбраны, тк они представляют наиболее удобный функционал для
# хранения парных значений, с которыми мы и оперируем

# Была мысль не сохранять отдельно имена, хобби в каждый список для этого, а использовать для этого генераторы,
# генератор был написан, но возвращал сразу все данные из файла при yield, поэтому буду признателен, если подскажете,
# как можно было бы его реализовать и как к нему затем лучше обращаться, в смысле как заполнить словарь,
# используя этот генератор

# Вот пробный код генератора, после которого я отступил, но есть ощущение, что такой подход имел место быть:

# def return_name(repeats):
#     with open('users.csv', 'r', encoding='utf8') as f:
#         for line in f:
#             yield line.strip()
#
#
# def return_hobby(repeats):
#     with open('hobby.csv', 'r', encoding='utf8') as f:
#         for line in f:
#             yield line.strip()
#
#
# names_hobiies_dict = {return_name(i): return_hobby(i) for i in range(0, 2)}
