# 3. Написать декоратор для логирования типов позиционных аргументов функции, например:
# def type_logger...
#     ...
#
#
# @type_logger
# def calc_cube(x):
#    return x ** 3
#
# >>> a = calc_cube(5) 5: <class 'int'> Примечание: если аргументов несколько - выводить данные о каждом через
# запятую; можете ли вы вывести тип значения функции? Сможете ли решить задачу для именованных аргументов? Сможете ли
# вы замаскировать работу декоратора? Сможете ли вывести имя функции, например, в виде: >>> a = calc_cube(5)
# calc_cube(5: <class 'int'>)

from functools import wraps

def type_loger(func):

    print(type(func))

    @wraps(func)
    def type_log(*args, **kwargs):
        for arg in args:
            print(f'{func.__name__}({arg}: {type(arg)})', end=', ')
        for key, val in kwargs.items():
            print(f'{func.__name__}({val}: {type(val)})', end=', ')
        logs = func(*args, **kwargs)
        return logs

    return type_log


@type_loger
def calc_cube(x):
    return x ** 3


calc_cube(3)

# решение для именованных аргументов сделал через кваргс, а точнее проходя по парам - выдаю значение для ключа
# для вывода - обращаюсь к имени через func.__name__
# не совсем понял вопрос про тип значения функции, ведь если число целое, то тип результата будет тоже целым, с дробным также
# поэтому в строке 17 написал какую-то бессмыслицу, вроде как
# не совсем сообразил, как сделать выводы через map, но думаю это от меня и требовалось
# также в независимости от того, ставлю ли я wraps - вывод не меняется